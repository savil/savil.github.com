<!DOCTYPE HTML>
<html>
  <head>
    <meta charset="utf8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>Stanford BPASE 2018 Day One</title>

    <link rel="stylesheet" href="/css/sitewide.css">
    <link rel="stylesheet" href="/css/post.css">
  </head>
  <body>
    <div class="post_container">
      <div class="home_link_container">
        <a href="/">homeward bound.</a>
      </div>
      <div class="post_title">
        Stanford BPASE 2018 Day One
      </div>
      <div class="post_date">
        2018 . 01 . 24
      </div>
      ...
      <p>You can find the program for the conference and slides/videos <a href="https://cyber.stanford.edu/bpase18">here</a>.</p>

<h2 id="intro">Intro talk</h2>
<p>by Byron Gibson (i think)</p>

<p>This conference deals with a few kinds of security:</p>
<ul>
  <li>data integrity</li>
  <li>fiduciary security</li>
  <li>system security</li>
</ul>

<p>Some themes that will be covered:</p>
<ul>
  <li>adversarial thinking</li>
  <li>cryptographic primitives</li>
  <li>programming interfaces/languages</li>
  <li>consensus and secure scaling</li>
</ul>

<h2 id="talk1">Talk 1: Game theory and network attacks: how to destroy bitcoin</h2>
<p><a href="https://twitter.com/MaxFangX">Max Fang</a>. blockchain at berkeley: CS+Econ at UC Berkeley.
<a href="https://cyber.stanford.edu/sites/default/files/20180124_bpase_game_theoretical_attacks_on_bitcoin.pdf">slides</a>.</p>

<p>This talk is a survey of attacks. For an excellent overview of mining attacks with beautiful illustrations, <a href="https://hacken.io/wp-content/uploads/The-Rush-for-Hashpower.pdf">see this pdf</a>.</p>

<h3 id="selfish-mining">selfish mining</h3>
<ul>
  <li>
    <p>paper: <a href="https://www.cs.cornell.edu/~ie53/publications/btcProcFC.pdf">“Majority is not enough”</a></p>
  </li>
  <li>this is a block-withholding scheme.</li>
  <li>normally, a miner would publish the block as soon as they find a valid block.</li>
  <li>but they could keep it secret!</li>
  <li>goal: find two blocks before the network finds the next one</li>
  <li>the rest of the network, on the honest chain, thinks it is on the longest chain. But the miner has a longer chain, and this gives the miner some advantages.</li>
  <li>when the miner finds the second block, they broadcast both the blocks =&gt; miner’s chain is longer =&gt; win!</li>
  <li>works because this miner got “free time” mining on network (for second block) while rest were finding first block</li>
  <li>this way they gain larger effective hashrate =&gt; greater expected profits!</li>
</ul>

<p>Variation: what happens if the network found a valid block, before this miner finds the second block?</p>
<ul>
  <li>this leads to a race-to-propagate:
    <ul>
      <li>if miner has 25% network hashrate, and assuming 50% of network chooses attacker’s chain, then malicious strategy is more profitable.</li>
      <li>if miner has 33% network hashrate, then malicious strategy is more profitable, regardless of which chain the network chooses.</li>
      <li>why: intuitively we can consider that
        <ul>
          <li>(a) the attacker has had more time to mine the second block on its chain</li>
          <li>more importantly, (b) the honest network’s hashrate gets divided into two. So, if all the attacker’s (~25%) hashrate is focussed on the attacker’s chain then it can make progress faster.</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h3 id="stubborn-mining-model">stubborn mining model</h3>
<ul>
  <li>model for thinking about <a href="https://eprint.iacr.org/2015/796">selfish mining, by: Nayak, Kumar, Miller, Shi</a></li>
  <li>basic idea: can tell rest of network faster than others</li>
</ul>

<p>formal model:</p>
<ul>
  <li>let’s have Alice as the attacker (i.e. attacker’s hashrate), and Bob as the innocent miner (i.e. honest network’s hashrate).</li>
  <li>lead: defined as how much of Alice’s chain is ahead of Bob’s. Let’s call this: N.</li>
  <li>N’: there is a fork
    <ul>
      <li>revealed portion of the fork is equal length</li>
      <li>bob’s mining power is split by these two forks.</li>
    </ul>
  </li>
  <li>Can make a markov model to represent the “lead”.</li>
  <li>The honest network’s hash power can get split between honest network and selfish network, assuming “high connectivity” by the attacker.</li>
</ul>

<p>Stubborn strategies:</p>
<ul>
  <li>lead stubborn mining: if private-chain has a lead, and honest chain mines a block, then private chain only reveals one block and not all of its lead. This way honest network may keep mining (partly, because there are now two competing chains and hash power will get divided), and the private chain gets a chance to invalidate several honest blocks.</li>
  <li>equal fork stubborn: if private-chain is one ahead, and honest chain mines a block, and such a race is happening, then when private-chain mines a new block it withholds it until the honest chain also mines a new block. This way, can again hope to invalidate multiple honest blocks.</li>
  <li>trail stubborn: even if the honest network is one ahead, the attacker continues trying to mine on its private chain. This strategy is abandoned when the private chain is two blocks behind the honest chain.</li>
</ul>

<h3 id="selfish-mining-defenses">selfish mining defenses</h3>
<ul>
  <li>uniform tie breaking:
    <ul>
      <li>for two blocks that you hear about. Randomly choose between them.
        <ul>
          <li>Prevents attacker from benefiting from additional network connectivity.</li>
          <li>some disagreement in literature on profit threshold. Original authors claim this raises threshold from 0% to 25%, others say: 23.2%.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>unforgeable timestamps (Ethan heilman 2014)
    <ul>
      <li>each miner uses block with fresher timestamp</li>
      <li>raises profit-threshold to 32%</li>
    </ul>
  </li>
  <li>
    <p>note: these strategies above only apply to block-propagation races, not to longer chain attacks.</p>
  </li>
  <li>publish or perish defence: zhang and preneel 2017
    <ul>
      <li>backwards compat, no hard fork needed</li>
      <li>can still disincentivize selfish mining even with longer chain</li>
      <li>replace bitcoin fork resolving policy (FRP) with weighted FRP</li>
      <li>basic idea: weight depends on being published in a certain time-window.</li>
      <li>
        <p>secret block that is withheld doesn’t get any weight.</p>
      </li>
      <li>limitations:
        <ul>
          <li>assumes synchronous model for bitcoin blockchain. But bitcoin is async =&gt; this defence is useless.</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h3 id="game-theory-based-censorship">Game Theory based censorship</h3>
<p>want to prevent someone’s transactions. 
Let’s imagine we have GJ = gary johnson = a prototypical libertarian. 
and we have a Censor = e.g. China.</p>

<ul>
  <li>first try: blacklist
    <ul>
      <li>only works if have 100% power on network.</li>
      <li>even 90% only causes delays</li>
    </ul>
  </li>
  <li>second try: punitive forking
    <ul>
      <li>have &gt; 51% hashrate</li>
      <li>mandate that chinese pools do not include GJ’s tx</li>
      <li>if non-chinese miners include tx, then chinese miners fork and make longer chain</li>
      <li>other miners eventually give up!</li>
    </ul>
  </li>
  <li>blacklisting via “feather forking”:
    <ul>
      <li>attacker will attempt to fork, but if it doesn’t work out, then give up and go back to main chain</li>
      <li>give up after k transactions</li>
      <li>q: network hashrate that attacker has, where 0 &lt; q &lt; 1</li>
      <li>if k = 1, give up after one confirmation (one block more) =&gt; chance of successfully orphaning Johnson block = q^2</li>
      <li>q = 0.2 (20% network hashrate), q^2 = 4%</li>
      <li>now, other miners are aware of q^2 chance of their block being rejected</li>
      <li><code class="highlighter-rouge">E[include GJ tx] = (1-q^2) * block_reward + GJ tx free</code></li>
      <li><code class="highlighter-rouge">E[don't include] = block_reward</code></li>
      <li>hence, GJ must pay <code class="highlighter-rouge">q^2 * block_reward</code> in fees for tx to be included</li>
      <li>concretely, <code class="highlighter-rouge">4% * 12.5 BTC = 0.5 BTC</code> =&gt; GJ must pay $5,500 in fees</li>
      <li>but don’t see instances of this attack on the network, yet!</li>
    </ul>
  </li>
</ul>

<h3 id="51-attacks-and-collusions">51% attacks and collusions</h3>
<ul>
  <li>Martin Koppelmann, SF bitcoin devs</li>
  <li>Lemma 1: mining reward = mining cost (b/c mining needs electricity)</li>
  <li>Lemma 2: cost of acquiring 51% is approximately 0, and is less than mining cost (this is marginal cost, basically need more capital to mine more)</li>
  <li>Lemma 3: value of 51% attack &gt; mining reward
    <ul>
      <li>can effectively get all minnig rewards, because can continue on your own chain</li>
      <li>q = 51% =&gt; 49% of blocks orphaned</li>
      <li>q = 80% =&gt; 20% of blocks orphaned, most btc users not affected</li>
    </ul>
  </li>
  <li>
    <p>Conclusion: value of 51% attack &gt; cost of acquiring 51% hashrate. Very profitable!</p>
  </li>
  <li>btc mining is zero sum, must exclude others</li>
  <li>members-only mining
    <ul>
      <li>let hashrate join a collusion until 80% of network is in, then exclude rest</li>
      <li>no incentive not to join
        <ul>
          <li>attack succeeds =&gt; get more rewards</li>
          <li>fails =&gt; conduct attack in a way it won’t start until threshold is reached</li>
        </ul>
      </li>
      <li>game theory -&gt; this should happen!</li>
    </ul>
  </li>
  <li>naive example:</li>
  <li>3 pools collude =&gt; more than 51%</li>
  <li>if more 10th block of another pool?</li>
  <li>how to detect?</li>
</ul>

<p>practical caveats:</p>
<ul>
  <li>need lots of risk or capital
    <ul>
      <li>need tons of mining hw</li>
    </ul>
  </li>
  <li>hard to write and deploy exploit software</li>
  <li>insufficiently motivated miners
takeaway: social structure is important. world is not rational.</li>
  <li>need to look at behavioral economics, sociology, psychology to ask why this hasn’t happened yet!</li>
</ul>

<h2 id="talk2">Talk 2: State of the art attacks on secure hardware wallets</h2>
<p>by Charles Guillemet, CSO at Ledger</p>

<p>Outline:</p>
<ul>
  <li>intro</li>
  <li>software attack vectors</li>
  <li>physical attacks
    <ul>
      <li>principles</li>
      <li>ink cartridge attacks, ounterffeiting</li>
    </ul>
  </li>
  <li>perturbation attacks
    <ul>
      <li>principles</li>
      <li>set top box examples</li>
    </ul>
  </li>
  <li>side channel attacks (?)
…</li>
</ul>

<p>Ledgers have:</p>
<ul>
  <li>secure element (used in smartcards)
    <ul>
      <li>used for sim, passport, banking cards, TPM (??)</li>
      <li>store private key, and signature computed within here</li>
    </ul>
  </li>
  <li>pin code : 4-8 digits</li>
  <li>malware proof: designed to protect on untrusted computer</li>
</ul>

<p>Reminder: Secure software is super hard</p>

<ul>
  <li>Smartcard:
    <ul>
      <li>put all security part in a dedicated IC</li>
      <li>attacker may have physical access</li>
      <li>big actors: Samsung, etc.</li>
      <li>framework, attacker has physical access:
        <ul>
          <li>sw attack</li>
          <li>physical</li>
          <li>pertubation</li>
          <li>side channel</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>sw attacks
    <ul>
      <li>hard to secure: run code on untrusted platforms, or with root privileges</li>
      <li>hardware devices have interfaces</li>
      <li>IOs secured against classical attacks (like buffer overflow)
        <ul>
          <li>sometimes possible to load and run code</li>
        </ul>
      </li>
      <li>isolation must be ensured (Javacard firewall, custom OS with isolation using hw)</li>
      <li>attack surface of sw attacks is small by design</li>
    </ul>
  </li>
  <li>physical attacks
    <ul>
      <li>modify circuit to gain access to secrets or counterfeit certificate</li>
      <li>Focalized Ion Beam (FIB), circuit modification
        <ul>
          <li>locally edit circuit</li>
          <li>signals (like key registers) are probed</li>
          <li>cost of a FIB machine is $1k/day, or $1.5M total</li>
          <li>lots of time and expertise needed</li>
          <li>lots of countermeasures exist</li>
          <li>there is some way today to access flash memory</li>
        </ul>
      </li>
      <li>reverse engineering IC, using Scanning Electron Microscope (SEM) and chemicals
        <ul>
          <li>chemical deprocessing layers of circuit</li>
          <li>pictures taken, semiautomatic process to reverse circuit</li>
          <li>very costly, high know-how, time consuming</li>
          <li>this attack is used in video game industry and ink cartrdiges
            <ul>
              <li>ink cartridge: mutual authentication between printer and ink cartridge to avoid counterfeiting.</li>
              <li>Several Billion $ market.</li>
              <li>solutions use secure element: obfuscation, encrypted nvm, active shield.</li>
              <li>but attackers have cracked this</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>x-ray circuit modification (paper: nanofocussed x-ray bean to reprogram secure circuits)</li>
    </ul>
  </li>
  <li>pertubation attacks
    <ul>
      <li>use laser, emi (electromagnetic injetion), glitches via lasers</li>
      <li>lasers shot on circuit =&gt; produce induced current that switches values of bits used in circuit.
        <ul>
          <li>laser is efficient because local</li>
          <li>code rerouting: false pin or wrong signature acceptance</li>
          <li>attacks on cryptography related computations
            <ul>
              <li>differential fault analysis - RSA (Bellcore’s attack)</li>
              <li>DFA on AES (Piret and Quisquater’s paper)</li>
            </ul>
          </li>
          <li>in both attacks above, one fault gives away the private key</li>
          <li>very efficient attacks but there are countermeasures one can employ:
            <ul>
              <li>prevention: shielding IC (but not always possible), packaging, randomization make synchronization difficult</li>
              <li>detection: light detectors / CRC / double (or more) computations / control flow</li>
              <li>reaction:  at fault detection =&gt; erase keys or reset or destroy device</li>
            </ul>
          </li>
          <li>famous example: pay tv (20 years ago).
            <ul>
              <li>simple, lots of money</li>
              <li>set top box + smart card</li>
              <li>gets scrambled message, smart card returns “control word”, outputs descrambled content</li>
              <li>once attacker gets control word, it is shared over internet!</li>
              <li>today:
                <ul>
                  <li>encrypted(CW) with pairing key that changes every 10 seconds. This E(CW) is returned from smart card.</li>
                  <li>BUT: every 10 seconds, full attack is done (takes ~100ms), session key is found and shared on internet</li>
                  <li>BUT BUT: can also get the pairing key, and now no timing constraints!
                    <ul>
                      <li>techniques:
                        <ul>
                          <li>…see side channel attacks</li>
                        </ul>
                      </li>
                    </ul>
                  </li>
                </ul>
              </li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>side channel attacks
    <ul>
      <li>measure power consumption/EM during crypto computations</li>
      <li>record traces</li>
      <li>post processing traces</li>
      <li>conduct side channel analysis</li>
      <li>
        <p>attacks since 90s, using ML based attacks in 2015-16</p>
      </li>
      <li>timing attacks &amp; Simple Power Analysis (SPA)
        <ul>
          <li>retrieving sensitive info based on duration of computation</li>
          <li>e.g. password checking with early return</li>
          <li>SPA: example of “square and multiply”.</li>
        </ul>
      </li>
      <li>DPA: statistical attack
        <ul>
          <li>targets one intermediate value (a bit) which depends on key.</li>
          <li>exploit a statistical difference: if power consumption or EM is different when this bit is 1 versus 0.</li>
        </ul>
      </li>
      <li>CPA: generalizes DPA attack assuming power consumption model.
        <ul>
          <li>C = a.HW(x) + b, where C = measured power consumption, and HW is hamming weight of sensitive value x.</li>
        </ul>
      </li>
      <li>template attacks:
        <ul>
          <li>instead of assuming a leakage model, model is observed on a sample with a known key</li>
          <li>two stages:
            <ul>
              <li>stage 1: profile on known value to build model</li>
              <li>stage 2: using the model on targetted value</li>
            </ul>
          </li>
          <li>european certification requires protection against template attacks up to several million traces for stage 1 and 1 million for stage 2.</li>
          <li>secure products add countermeasures but others (like yubikey, or tv set top box) don’t.</li>
          <li>attack is cheap and efficient</li>
        </ul>
      </li>
      <li>ML based side channel attacks
        <ul>
          <li>classification problem</li>
          <li>template =&gt; supervised learning</li>
          <li>CPA, DPA =&gt; unsupervised learning</li>
          <li>Resynchronization effort is minimised</li>
          <li>countermeasure is to insert a “jitter” (?) in the trace</li>
          <li>not too many articles published on this, but protection against is required by some certification authorities.</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p>Conclusion:</p>
<ul>
  <li>lessons
    <ul>
      <li>if stakes are high, expect attackers will have high potential</li>
      <li>crypto is a big new target (like passport, banks, ink cartridges, set top tv from before)</li>
      <li>software solutions are hard to secure</li>
      <li>dedicated hardware is a better approach</li>
    </ul>
  </li>
</ul>

<h2 id="talk3">Talk 3: smart contracts for bribing miners</h2>
<p>by Patrick McCorry: <a href="https://twitter.com/paddyucl">@paddyucl</a>. <a href="http://homepages.cs.ncl.ac.uk/patrick.mccorry/minerbribery.pdf">Paper</a></p>

<p>useful background info:</p>

<ul>
  <li>miner incentives:
    <ul>
      <li>long term: want network to succeed</li>
      <li>short term: may deviate for profit =&gt; tragedy of the commons!
        <ul>
          <li>example:
            <ul>
              <li>founder of BTC.TOP offered $100 million to kill some fork of btc.</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>whale tx
        <ul>
          <li>a tx that has a large fee for the miners</li>
          <li>problem: asymmetrical trust for briber or bribed miner =&gt; briber has to trust miner, or miner has to trust briber.</li>
        </ul>
      </li>
      <li>script puzzles
        <ul>
          <li>divert hashrate from mining to solving the puzzle.</li>
          <li>problem: weaken longest chain overall weight</li>
        </ul>
      </li>
      <li>proof of stale block
        <ul>
          <li>ethereum contract rewards miners for withholding blocks in btc</li>
          <li>problem: contract cannot verify block’s correctness</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <p>can smart-contract impact nakamoto-style consensus?</p>

    <ul>
      <li>censorshipCon: briber seeks to censor tx
        <ul>
          <li>attacker to miner: please pursue uncle block mining strategy
            <ul>
              <li>uncle block: stale blocks later introduced in blockchain</li>
              <li>ethereum rewards via “uncle block reward policy”
                <ul>
                  <li>You can find Ethereum’s design rationale for uncle blocks <a href="https://github.com/ethereum/wiki/wiki/Design-Rationale#uncle-incentivization">here</a>.</li>
                </ul>
              </li>
            </ul>
          </li>
          <li>this way, network funds bribery attack.</li>
          <li>assumptions:
            <ul>
              <li>attacker has convinced sufficient % of miners to join</li>
              <li>attacker will include all uncle blocks and accept bribe tx -&gt; this subsidises her</li>
            </ul>
          </li>
          <li>step 1: let’s assume uncle block was mined and included in blockchain</li>
          <li>step 2: miner sends contract that has 3 diff block headers. Namely: uncle block, competing block (same level as uncle block), publisher block (has header of uncle block).
            <ul>
              <li>contract checks:
                <ol>
                  <li>verify that Attacker’s competing block and the publisher block are in the blockchain.</li>
                  <li>the publisher block has indeed included the header of the uncle block</li>
                  <li>the competing block and uncle block extend the same parent block i.e. prove they are at the same level.</li>
                </ol>
              </li>
              <li>c_payout = c_bribe + c_block - c_uncle
                <ul>
                  <li>the c_uncle that is issued to the miner is instead consumed by the attacker, thereby subsidizing her.</li>
                </ul>
              </li>
              <li>ethereum limits number of uncle blocks to 2, per block</li>
              <li>for each uncle block:
                <ul>
                  <li>network pays 2.625 eth</li>
                  <li>Alice pays…</li>
                </ul>
              </li>
            </ul>
          </li>
        </ul>
      </li>
      <li>historyRevisionCon:
        <ul>
          <li>reverse tx to enable double spending.</li>
          <li>assume:
            <ul>
              <li>no asymetrical trust assumptions between the briber and the miner. Neither party needs to trust the other.
                <ul>
                  <li>if miners don’t trust the briber =&gt; then briber must sign a list of tx in advance with incrementing time-locks (to ensure only a single bribe is included per block)</li>
                  <li>if briber doesn’t trust the miners =&gt; can include a whale tx (with incentive of large fee) after each block in the alternate chain.</li>
                </ul>
              </li>
              <li>contract’s integrity not affected, by forks.</li>
            </ul>
          </li>
          <li>lets have three accounts:
            <ul>
              <li>A1 = 10 coins. creates and funds contract.</li>
              <li>A2 = 100 coins to double spend. Spends coins in the longest chain.</li>
              <li>A3 = 0 coins. to receive double-spend coins. Receives coins from A2 in the alternate-chain.</li>
            </ul>
          </li>
          <li>wait until A2 is confirmed in blockchain.</li>
          <li>Alice publishes two tx:
            <ol>
              <li>double spend tx. send 100 coins from A2 to A3.</li>
              <li>tx to create the historyRevisionCon contract.</li>
            </ol>
          </li>
          <li>first block: both tx from alice + accept-bribe tx. Makes new fork.
            <ul>
              <li>in every block in this alternate chain, the accept-bribe tx must be included. It will check that a bribe has not been paid for this block, and send the bribe-money to the miner.</li>
            </ul>
          </li>
          <li>analysis. Notice there are two modes of payment:
            <ol>
              <li>every block that gets included in the final blockchain.</li>
              <li>or if not included, then every uncle block (similar to CensorshipCon)
                <ul>
                  <li>win win for miner</li>
                </ul>
              </li>
            </ol>
          </li>
          <li>Alice doesn’t need any hashrate for this attack</li>
          <li>more than double-spending:
            <ul>
              <li>inspect state of other contracts - reverse computations and state contracts</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>GoldfingerCon:
        <ul>
          <li>reduce utility of competing cryptocurrency (e.g. make btc less useful)</li>
          <li>assumptions:
            <ul>
              <li>no asymetrical trust assumptions</li>
              <li>briber remains online to publish bribed blocks</li>
            </ul>
          </li>
          <li>method:
            <ul>
              <li>have miner mine empty blocks in btc, and then prove in ethereum contract that they did this.</li>
              <li>miner publishes empty block in btc. This comprises of the coinbase transaction.</li>
              <li>in ethereum, he publishes a transaction for “accept bribe”, that:
                <ul>
                  <li>has the btc-block-header, and the coinbase-tx</li>
                  <li>calls GoldFingerCon contract’s AcceptBribe function that needs to verify the btc-block is empty.
                    <ul>
                      <li>the block is proved empty by checking that the merkle tree root is the same as the coinbase-tx hash.
                        <ul>
                          <li>TODO savil. how does ethereum look up properties of the btc-blockchain?</li>
                        </ul>
                      </li>
                    </ul>
                  </li>
                  <li>the contract then sends the reward to the ethereum address of the miner.</li>
                </ul>
              </li>
              <li>this ethereum address is calculated by: extract public-key from coinbase-tx output, and compute the ethereum address for this public-key.</li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p>future work:</p>
<ul>
  <li>ramp up: assume majority of miners to participate
    <ul>
      <li>to incentize this, can set time-limits for certain events before voiding the contract.
        <ul>
          <li>For example, in GoldfingerCon, could specify that x% of blocks must be mined by time t1, then 2x% of blocks by time t2, and so on.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>impact of selfish mining in combination with bribery attacks for attacking and defending network</li>
  <li>can bribery ctx by used in proof-of-stake, and are there fundamental diff in style of bribery?
    <ul>
      <li>same coin can be used for both voting rights and paying bribes.</li>
    </ul>
  </li>
</ul>

<h2 id="talk4">Talk 4: Formal Barriers to Proof of Stake Protocols</h2>
<p>By Jonah Brown-Cohen et al</p>

<p>Proof of Stake:</p>
<ul>
  <li>random miner chosen probabilistically proportional to wealth.</li>
  <li>one coin, one vote, rather than one cpu, one vote</li>
  <li>can similar security to pow be achieved?</li>
  <li>this talk does an incentive-driven analysis: identify incentive problems not in pow</li>
</ul>

<p>Talk outline:</p>
<ol>
  <li>a model for analyzing incentives in pos</li>
  <li>properties such that every protocol in model satisfies one of these properties</li>
  <li>for each property, incentive driven attacks against the protocol that satisfies this property</li>
</ol>

<p>disclaimer: attacks are well understood, but for a broad class of protocols these attacks work better than pow</p>

<p>intuition:</p>
<ul>
  <li>need source of pseudorandomness to pick random miner</li>
  <li>pow: comes from brute force guessing of nonce</li>
  <li>pos: comes from protocol itself</li>
</ul>

<p>Jonah proposes the following model</p>
<ol>
  <li>use some method to pick coin</li>
  <li>use some method to pick existing block
    <ul>
      <li>TODO savil: won’t this always be the last “mined” block?</li>
    </ul>
  </li>
  <li>owner of coin gets to add new block</li>
  <li>repeat</li>
</ol>

<p>Formal notation:</p>
<ul>
  <li>B, is a block that has: t(B) timestamp, c(B) coin, miner(B), contents</li>
  <li>A = Pred(B), the previous block in the chain</li>
  <li>for a block B, history of tx in B and Pred(B) define ownership of coins marked as owner(c(B)).</li>
</ul>

<p>assumptions:</p>
<ol>
  <li>chain dependence: validity of B at t depends only on t and Pred(B)</li>
  <li>monotonicity: if B is valid at time t, then valid at all future times t’ &gt; t
    <ul>
      <li>even if not on longest chain, block is still “valid”
These assumptions hold for pow protocols like btc. These assumptions means we don’t consider <a href="https://www.usenix.org/node/190891">“eclipse-attacks”</a> as threats in this model (although they exist in real life).</li>
    </ul>
  </li>
</ol>

<p>POS, has two functions:</p>
<ol>
  <li>validating function V
    <ul>
      <li>efficiently computable by every protocol participant</li>
      <li>B with A = Pred(B) is valid at t if and only if</li>
    </ul>
    <ul>
      <li>V(B) = 1</li>
      <li>Miner(B) = Owner(c(B)) at A</li>
      <li>t(A) &lt;= t(B) &lt;= t</li>
    </ul>
  </li>
  <li>mining function M: inputs are B, coin c, timestamp t =&gt; outputs new block
    <ul>
      <li>M(A, c, tv) is efficiently computable by owner</li>
      <li>if there is a valid block, then mining function should actually mine something</li>
    </ul>
  </li>
</ol>

<p>Longest-chain protocol</p>

<ul>
  <li>Properties:
    <ul>
      <li>Property 1: D-Locally Predictable
        <ul>
          <li>For coin c, owner(c) can predict D blocks in advance that she is eligible to use c to mine a block</li>
          <li>every POS protocol is 1-locally predicatable.</li>
          <li>but 1-local predictability can be chained on a private fork, letting one predict far in advance how many future blocks one can mine.</li>
        </ul>
      </li>
      <li>Property 2: D-Globally predictable
        <ul>
          <li>every protocol participant can predict whether owner(c) is eligible to use c to mine, D blocks in advance.</li>
        </ul>
      </li>
      <li>
        <p>Two extreme xamples:</p>

        <ol>
          <li>V(B) = 1 &lt;=&gt; Hash(c(B), t(B)) &lt; Threshold =&gt; globally predictable for all D
            <ul>
              <li>this was original POS proposal, where this Hash function replaces the btc-nonce.</li>
            </ul>
          </li>
          <li>protocol where:
            <ul>
              <li>every block contains signature s(B)</li>
              <li>M(A, c, t) = B where s(B) = SIG(Hash(s(A), t), where SIG is signed by private key of owner(c)</li>
              <li>V(B) = 1 &lt;=&gt; H(s(B)) &lt; T</li>
              <li>this is not globally predictable for anyone. It is 1-locally predictable.</li>
              <li>based on Algorand’s protocol</li>
              <li>here s(A) becomes the source of pseudorandomness</li>
            </ul>
          </li>
        </ol>
      </li>
      <li>Property 3: D-recent
        <ul>
          <li>miner of C cannot efficiently predict D blocks in advance if she is eligible to mine a block.</li>
          <li>negation of D-locally predictable</li>
          <li>blocks [1, D-1] provide the source of pseudo-randomness</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p>Attack: predictable selfish mining:</p>
<ul>
  <li>withhold a newly mined block B and secretly try to mine on top of it</li>
  <li>if you mine another B’ =&gt; then you have a chance to push a longer chain</li>
  <li>with global predictability =&gt; no risk! can predict precisely when you can mine k blocks faster than rest of miners</li>
  <li>with 1-local predictability =&gt; reduced risk! can predict how fast you can mine k blocks, compared to average rate</li>
</ul>

<p>Attack: predictable double spending</p>
<ul>
  <li>you want to predict private fork, but do so to cancel some tx</li>
  <li>predict you can produce secret fork of k blocks</li>
  <li>buy $$, if delivered before k blocks are mined then include conflicting tx on secret-fork, then publish the fork!</li>
  <li>D-predictability for large values of D =&gt; gives time to prepare for launching an attack</li>
  <li>could be useful to prepare for stranger attacks by offering to take a bribe</li>
</ul>

<p>Attacks: undetectable nothing-at-stake</p>
<ul>
  <li>for d-recent protocols, blocks A and B at two ends of length D fork have “independent pseudorandomness”</li>
  <li>trying to mine on both sides of fork, doubles chances of successfully mining</li>
  <li>
    <p>if all coins are held in diff accounts, can make attack undetectable</p>
  </li>
  <li>Existing protocols:</li>
  <li>D-globally predictable:
    <ul>
      <li>cardano, large D</li>
      <li>peercoin, for all D</li>
      <li>tezos, for large D</li>
    </ul>
  </li>
  <li>1-locally predictable and 2-recent
    <ul>
      <li>algorand (would be vuln to nothing-at-stake attack but not longest chain)</li>
    </ul>
  </li>
</ul>

<p>Conclusion:</p>
<ul>
  <li>Predictability versus recency is a tradeoff: if choose one, then protocol designers must add mitigating measures or protection against attacks from other.</li>
  <li>1-local predictability is necessary</li>
  <li>global-predictability is not necessary =&gt; can eliminate at the cost of a digital sig at every …stake?</li>
</ul>

<p>q by ken huang: for casper</p>
<ul>
  <li>opinion: be recent</li>
  <li>casper is going to be recent and bounty-hunting for nothing-at-stake</li>
  <li>need to measure how much benefit to selfish mining increases by bounty-hunting (“slashing”)</li>
</ul>

<p>q: alternatives to pos</p>
<ul>
  <li>rely on some other source of randomness in the world</li>
</ul>

<p>q: ?</p>
<ul>
  <li>penalties for mining on wrong fork</li>
  <li>stop accepting blocks mined older than .5 seconds. How to protect against network latency or attacks?</li>
</ul>

<p>q: smaller the D, may affect entropy of seed that is used to randomly select miners?</p>
<ul>
  <li>depends on how protocol is implemented.
    <ul>
      <li>e.g. look back 1000 blocks, and use all of that randomness. That is 1000-predictable in model.</li>
    </ul>
  </li>
</ul>

<p>q: asynchrony plays a role.
the more synchronicity you assume, the more you can eliminate selfish mining</p>

<p>q: check out Dfinity (not a question)</p>
<ul>
  <li>but <a href="https://medium.com/dfinity/dfinity-white-paper-our-consensus-algorithm-a11adc0a054c">the paper is here</a></li>
</ul>

<h2 id="talk5">Talk 5: programming incentives: an intro to cryptonomics</h2>
<p>by Karl Floersch, Ethereum Foundation</p>

<p>On casper protocol</p>

<p>pow:
has incentive to mine on the longest chain =&gt; casper needs to solve this</p>

<p>problems:</p>
<ol>
  <li>waste of energy</li>
  <li>vuln to asic and centralization
    <ul>
      <li>makes chain reversion relatively low cost</li>
    </ul>
    <ul>
      <li>no inprotocol penalty for reversion</li>
    </ul>
  </li>
  <li>no “finality”
    <ul>
      <li>UASF exploited this vuln</li>
    </ul>
  </li>
  <li>no clear validator set
    <ul>
      <li>useful for: sharding, main chain consensus (casper), cryptoeconomic light clients (e.g. want to sync chain, get block from validator who signs that if block is not in main chain then loses deposit)</li>
    </ul>
  </li>
</ol>

<p>hybrid casper:</p>
<ul>
  <li>FFG (Friendly Finality Gadget): adding finality to eth main chain
    <ul>
      <li>every 50 blocks vote on whether block is in main chain</li>
      <li>reduces energy =&gt; lower block reward</li>
    </ul>
  </li>
  <li>any eth holder can become validator by depositing eth in casper smart contract</li>
  <li>staking pools can run casper themselves</li>
</ul>

<p>why deposits?</p>
<ul>
  <li>see validators as evil.</li>
  <li>Give larger incentives to work with.</li>
  <li>impose large penalty on bad actors.</li>
</ul>

<p>mechanism:</p>
<ul>
  <li>chain is chunked in 50 block segments called epochs</li>
  <li>every 50th block =&gt; checkpoints</li>
  <li>finality = 2/3 votes from validators</li>
  <li>waits till two checkpoints in a row</li>
  <li>every vote = prep of current epoch, and confirmation of previous epoch</li>
</ul>

<p>slashing conditions</p>
<ul>
  <li>solves nothing-at-stake problem</li>
  <li>if there are two chains that are finalized, then 1/3 of validator deposits are lost/”slashed”
    <ul>
      <li>no double votes =&gt; validator cannot vote on two conflicting chains</li>
      <li>no surround vote =&gt; cannot vote on two chains such that there’s a gap in between</li>
    </ul>
  </li>
  <li>see video about this</li>
</ul>

<p>designing casper FFG by Vlad and Vitalik</p>
<ul>
  <li>“minimal slashing conditions” =&gt; 4 conditions</li>
  <li>came with formal verification</li>
  <li>but we should use it when human intuitions are not enough, not a replacement for intuition</li>
</ul>

<p>“parameterizing casper: decentralization/finality tradeoff”</p>

<p>Q: ken huang
problems:</p>
<ol>
  <li>ddos against validation pool</li>
  <li>collusion in validation pool (67% attack)
Answer:
    <ul>
      <li>slashing means minority loses deposit. There is some paper about this.</li>
      <li>to mitigate: can fork off censoring chain (???)</li>
    </ul>
  </li>
</ol>

<ul>
  <li>in validation pool, run decentralized protocol to decide. Doesn’t need to be a central server.</li>
</ul>

<p>q. is there a complete final write up of the protocol? for academic contributions</p>
<ul>
  <li>go to ethereum website on casper basics</li>
</ul>

<p>q. planning to swap out consensus mechanism for $100B currency, does it worry you?</p>
<ul>
  <li>have mandate to move forward. ties in with sharding and plasma vision.</li>
  <li>schedule: have casper test net, have sharded eth node that is being developed, have plasma minimal viable. 3 fronts. no date.</li>
</ul>

<p>q (DHVC): path from hybrid to full?</p>
<ul>
  <li>one simple option: turn casper validator votes into blocks themselves. issue: have a 1000 validators, can one have a 1000 blocks to reach finality?</li>
  <li>casper ffg is a simplified expression within vlad’s framework. which is a 1 vote is 1 block view.</li>
</ul>

<p>q: smart contracts, have access to block info, and will there be access to epic/finalization info?</p>
<ul>
  <li>for plasma chains, this is important. we will probably see access to such apis.</li>
</ul>

<p>q: what is the simulation environment or research process?</p>
<ul>
  <li>risks of censorship or finality reversion. based on these risks, what rewards should we offer validators, or failure rates can we tolerate?</li>
</ul>

<h2 id="talk6">Talk 6: ThunderToken: blockchains with optimistic instant confirmation</h2>
<p>By Elaine Shi, Cornell and Thundertoken</p>

<ul>
  <li>what this talk is about:
    <ul>
      <li>Doing fas, block confirmation times.</li>
      <li>talk is about: core consensus and crash course on dist consensus</li>
      <li>not about: incentives and governance policy</li>
    </ul>
  </li>
  <li>motivation:
    <ul>
      <li>consider losses by airlines in reservation system downtimes</li>
      <li>need: replication and robustness</li>
      <li>this inspired dist. systems</li>
    </ul>
  </li>
  <li>state machine replication: linearly ordered log, and consensus
    <ul>
      <li>consistency: honest nodes agree on log</li>
      <li>liveness: txs are incorporated quickly</li>
      <li>implementation: “chubby lock service for loosely coupled dist systems” mike burrows, google -&gt; apache zookeeper</li>
    </ul>
  </li>
  <li>traditional consensus: single org, dozen servers, fast lan</li>
  <li>cryptocurrencies: aspire to large-scale deployments
    <ul>
      <li>in china, scale is 100 banks and 1000 nodes</li>
      <li>large scale dist protocols: chain.com, hyperledger, etc.</li>
    </ul>
  </li>
</ul>

<p>So, why is this not a solved problem? why roll one’s own?</p>
<ul>
  <li>Classical: e.g. pbft, paxos. Are fast BUT complex.</li>
  <li>Blockchains: e.g. “mathematics behind blockchains”[GKL’15][PSS’17].
    <ul>
      <li>Are simple, robust, but slow.</li>
      <li>are often wasteful</li>
      <li>assume: can remove pow from blockchains (“sleepy consensus” - PS16)</li>
      <li>some of the slowness is inevitable - there’s some paper about this.</li>
    </ul>
  </li>
  <li>voting based protocol
    <ul>
      <li>leader proposes (Seq, txs)</li>
      <li>everyone votes, but one can have a bad tx in it?</li>
      <li>honest nodes vote uniquely</li>
      <li>honest leader = consistency and liveness</li>
      <li>but dishonest leader = consistency but no liveness</li>
    </ul>
  </li>
  <li>in classical consensus, this voting has a simple normal path, but when something goes wrong, the recovery path is very complicated
    <ul>
      <li>e.g. chain.com only implemented the simple normal path, but not practical when so many actors involved (100 banks) to recover with.</li>
    </ul>
  </li>
  <li>high-level idea with thundertoken is to replace complicated recovery path with a blockchain.
    <ul>
      <li>simple and robust as a blockchain</li>
      <li>in optimistic case, need 2-3 “actual network rounds”</li>
      <li>in attack case, fallback to underlying blockchain</li>
    </ul>
  </li>
  <li>ethereum scenario:
    <ul>
      <li>leader, blockchain and committee (e.g. stakeholders, or banks in a trusted scenario)</li>
      <li>assumptions: assume miners are majority honest, and committee is majority honest (but need not be online)</li>
      <li>attempt 1:
        <ul>
          <li>vote on blocks, confirm a block upon collecting enough votes by the committee.</li>
          <li>problem: let’s imagine blockchain forks in the day (due to network delay), so people who made fork A are now inconsistent with fork B that later won out. So, even if it worked, must wait for 1 block interval.</li>
        </ul>
      </li>
      <li>attempt 2 (actual proposal):
        <ul>
          <li>leader proposes (seq, txs) and everyone votes on it</li>
          <li>for a tx to become “notarized”, it needs 3/4 of committee to vote</li>
        </ul>
      </li>
      <li>let’s imagine
        <ul>
          <li>tx1, tx2, tx3 are notarized &lt;– “confirm maximal lucky sequence”</li>
          <li>tx4 is not yet</li>
          <li>tx5, tx6 are notarized</li>
        </ul>
      </li>
      <li>crux of the problem: how do we solve the liveness issue if leader is corrupt or offline, or committee is offline?</li>
      <li>blockchain collects evidence of an attack in “fast path”, and upon detecting that we “enter the slow mode” via the blockchain. Once in the slow-mode, can use a smart-contract to elect a new leader and switch back to the fast-path.</li>
      <li>how to detect failure of the “fast path”?
        <ul>
          <li>the faulty nodes must not implicate honest leader. should be robust.</li>
          <li>miners must tell blockchain all the notarized and unnotarized tx, not just the confirmed tx as in traditional blockchains.</li>
          <li>if in a block, one observes an unconfirmed tx, then inspect k more blocks: and see that tx3 has still not appeared in a “lucky sequence” =&gt; fast-path has failed. If leader had been honest and online, and also the committee, then the unconfirmed-tx would have been confirmed by now =&gt; are in failure mode.</li>
        </ul>
      </li>
      <li>how does one enter slow mode?
        <ul>
          <li>nodes have different logs when entering slow mode. need to decide what is the cutoff. its an “agreement problem” in itself.</li>
          <li>introduce a “grace period” of k blocks (e.g. k = 6 or 10) … and some more details</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p>Summary:</p>
<ol>
  <li>when things are good: single round of voting when things are good</li>
  <li>when things are bad: use blockchain to “view change” when things go bad</li>
</ol>

<p>Insights gained:</p>
<ol>
  <li>claim a new theoretical paradigm.
    <ul>
      <li>In the old consensus, we have an asynchronous world, where the “bad path” makes solving this problem hard.</li>
      <li>with blockchain, we use a synchronous protocol.</li>
    </ul>
  </li>
  <li>“block interval must be constant time (O(1)) larger than max network delay”
    <ul>
      <li>“permissionless consensus has to be synchronous”</li>
    </ul>
  </li>
</ol>

<ul>
  <li>traditionally, we overlook synchrony because it is slow as far as common wisdom goes.</li>
  <li>but this may not be correct. Via thundertoken you can live in async “fast” land normally but can fallback into simple and robust synchronous protocol.</li>
</ul>

<p>q. what happens when underlying blockchain gets forked in the grace period?
a. grace-period should contain enough blocks (k should be sufficiently large). blockchain protocol is such that if you wait long enough then this is okay.</p>

<h2 id="talk7">Talk 7: smart signatures, experiments in authorization</h2>
<p>By Christopher Allen, blockstream</p>

<p>demo validity of a message, like RSA and standard is X.501
Trust policy: defined and limited by third-parties like a Certificate Authority and an app/browser/os</p>

<p>modern crypto allows: multi-sig, ring sig, blind sig, 
traditional sig: authenticate who signed message, and certify that the signing part is authorized to do the task</p>

<p>smart sig: core use - also authorization</p>
<ul>
  <li>additional parties can be authorized</li>
  <li>more operators like OR and AND</li>
</ul>

<p>Difference: trust policy not interpreted by a CA or code by app/browser/os</p>
<ul>
  <li>trust policy is embodied by the signer into the signature itself.</li>
</ul>

<p>inspiration: btc tx signature
has “Script” a stateless predicate language. many use-cases.</p>

<p>usecase:</p>
<ul>
  <li>multifactor expressions</li>
  <li>signature delegation, and limit the time for it, or limit to quantity of money, 
and optionally permanently pass control (e.g. employment changes)</li>
  <li>dev release/CI toolchain</li>
  <li>transactional support: signatures are part of a larger process, prvode specific tx states exist or test against oracles. For instance: prove provenance of art (via transaction history)</li>
</ul>

<p>language requirement:</p>
<ul>
  <li>composable: need simple data structures (stacks, lists, etc.), constrained set of operations to allow security review. like forth, scheme, haskell.</li>
  <li>inspectable: auditable by a programmer.</li>
  <li>provable: should be formally analyzable and support tools to discover hidden bugs.</li>
</ul>

<p>system requirements:</p>
<ul>
  <li>deterministic: script must produce same result.</li>
  <li>bounded: execution should not exceed cpu or memory limits, and size should be minimal and bounds should be deterministic</li>
  <li>efficient: no requirements on difficulty to create signature, but cannot be costly to verify.</li>
</ul>

<p>privacy?
tradeoff between flexibility and privacy. Smart signature may allow correlation. Reduces substituability and may break fungibility and beaer aspets.
advice: limit sharing an execute off-chain. be transparent and deliberate.</p>

<p>experiment: bitcoin Script</p>
<ul>
  <li>deterministics, bounded, efficient
? is it composable, and inspectable?</li>
  <li>not provable
no standalone version</li>
</ul>

<p>experiment: Ivy, by chain.com
compiles to btc script. easier syntax, static types.</p>
<ul>
  <li>inspectable btc Script</li>
  <li>same limitations as btc Script
whitepaper, full playground avaiblable</li>
</ul>

<p>experiment: Dex
Determistic Predicate by Peter Todd
Scheme-like lambda calculus
blogpost, no whitepaper or code</p>

<p>_ composable, determistic, efficient, bounded
kinda: inspectable, provable</p>

<p>experiment: Simplicity
by Russell O’Conor
Sequent Calculus</p>
<ul>
  <li>provable, deterministic, bounded, efficient, composable
kinda: inspectable
whitepaper, no code</li>
</ul>

<p>experiment: Sigma-State
Alexander Chepurnoy, optimized for zk-proofs, ring and threshold sigs, strongly typed</p>
<ul>
  <li>inspectable, composable, deterministic, efficient
kinda: provable, bounded</li>
</ul>

<p>experiment: Michelson
by Tezos, inspired by OCaml, is Stack-based like Script</p>
<ul>
  <li>composable, inspectable, efficient
kinda: provable, bounded, deterministic
whitepaper, playground</li>
</ul>

<p>experiment: crypto conditions
by Ripple for Interledger
not a language, a JSON description
easier testing, limited flexibility</p>
<ul>
  <li>boundded, efficient, deterministic
kindaL inspectable</li>
  <li>composable, provable</li>
</ul>

<p>… other “watching”
watching: bamboo on evm
jsript like
explicit state transitions
avoids reentrancy</p>

<p>open questions:</p>
<ul>
  <li>context
    <ul>
      <li>internal references?</li>
      <li>lists, trees, acyclic graphs</li>
      <li>run time context?</li>
      <li>external process state?</li>
    </ul>
  </li>
  <li>oracles:
    <ul>
      <li>preserving execution boundedness</li>
      <li>what are simple mvp oracles?</li>
    </ul>
  </li>
  <li>revocation
    <ul>
      <li>proof of non-revocation?</li>
      <li>make scripts have a short life versus revocation?</li>
    </ul>
  </li>
</ul>

<p>moar open questions:</p>
<ul>
  <li>object capabilities
    <ul>
      <li>are “ocap” and Least Authority architectures another use-case?</li>
    </ul>
  </li>
  <li>Cryptographic primitives
    <ul>
      <li>HD keys?</li>
      <li>Poelstra’s “Scriptless Scripts”: embedding multiple signatures into a single signature. gives privacy and other benefits.</li>
    </ul>
  </li>
  <li>Smart Contracts
    <ul>
      <li>is there value in non-predicate scripts? providing true or false, … or a hash?</li>
      <li>none of the experiments above are not Turing complete, but where exactly is the line between a SmartSignature contract and a regular SmartContract? is turing completeness the only criteria, or are there others?</li>
    </ul>
  </li>
</ul>

<p>“Smart signatures” paper</p>

<p>Language geeks: go to #RebootingWebOfTrust event march 6-8 in Santa Barbara</p>

<p>q. (ken huang) can one extend X.501 to have these scripts?
a. there has been some talk about this.
more interested in “verifiable creddentials or claims” community, using JSON that can be signed as a graph-signature.</p>

<p>q. (ken huang)…?
a. idea behind “self sovereign” identity. something something.</p>

<p>q. confused, you said “a smart signature is a predicate language” but Simplicity is more than that?
a. not turing complete, it unwinds all loops etc. 
and people want to use it for provable predicate scripts, but clearly can be used for more.
still suffers from re-entrancy</p>

<p>q. what was your role in “sovereign foundation”? you’d mentionedit and i missed it.
“sovereign foundation” are part of RebootingWebOfTrust community and working with W3C who have given permissions to move it forward as a “work item”.</p>

<h2 id="talk8">Talk 8: Hardening Lightning</h2>
<p>Olaoluwa Osuntokun</p>

<p>TODO savil. Unfortunately this talk went completely over my head. Speaker was clearly knowledgable but went too fast for me to keep up. Will need to read paper or watch the video/slides when posted.</p>

<h2 id="talk9">Talk 9:  Enter the Hydra: towards principled bug bounties and exploit-resistant smart contracts</h2>
<p>Florian Tramer et al:
www.thehydra.io making a ethereum contract development framework</p>

<p>bug bounties leverage crowd to find issues, rather than rely on small internal team of engineers to do so.
problems:</p>
<ul>
  <li>unaligned incentives. exploit $$$ &gt; bounty $</li>
  <li>time lag between reporting and action</li>
  <li>no fair exchange: bounty admin may not pay! don’t know ahead of time what the value of bounty is, so how do you know how many resources to put into it?</li>
</ul>

<p>perfect bug bounty should satisfy:</p>
<ul>
  <li>strong exploit gap: small bounty incentivises disclosure for valuable program
    <ul>
      <li>rational attacker’s game:
        <ul>
          <li>no bounties =&gt; found exploit =&gt; no dilemma, must exploit!</li>
          <li>classic bounty, unknown payout =&gt; doesn’t change much</li>
          <li>classic bounty, known payout =&gt; depends if attacker can earn more from exploiting</li>
          <li>known bounty, use “exploit gap” =&gt; use multi-version programs =&gt; from space program =&gt; have diff implementations of same spec =&gt; run all in parallel and check they agree =&gt; if one has a bug, check if majority of systems are correct =&gt; if majority have mistake, then we’re in trouble =&gt; if all don’t make same mistake in same way, can detect if something is wrong =&gt; if all fails in same way, then we’re screwed
            <ul>
              <li>assumes full independence of faults</li>
              <li>tried at nasa, not cost effective. Used 3x versions, got 4x fewer faults.</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>but smart contracts are diff:
        <ul>
          <li>in classical work, availability » reliability</li>
          <li>but in smart contracts: we don’t care if not available. We want N-out-of-N agreement, better “no answer” than “wrong answer”.</li>
          <li>“exploit gap” means that attacker must find bug simultaneously affecting all deployments. As soon as one is known to be “bad”, then we shut it all down.</li>
        </ul>
      </li>
      <li>smart contracts, have small contracts with lots of value per line:
        <ul>
          <li>omisego: 396 line of code</li>
          <li>tether: 423 lines</li>
          <li>EOS: 584 lines</li>
          <li>wtf</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>automatic remediation: immediate intervention in affected software
    <ul>
      <li>put money in escrow or return to sender, and figure out how to fix bug</li>
    </ul>
  </li>
  <li>automatic payout: must be censorship resistant, verifiable
    <ul>
      <li>use smart-contract to payout bounty, if we detect at runtime that there has been an exploit.</li>
    </ul>
  </li>
</ul>

<p>challenges</p>
<ul>
  <li>of coordinating multiple smart contracts:
    <ul>
      <li>coordinator needs to be a simple proxy, be bug free</li>
      <li>maintain consistent blockchain state</li>
      <li>how to recover from a discovered bug =&gt; escape hatches</li>
    </ul>
  </li>
  <li>frontrunning
    <ul>
      <li>attacker can break the “exploit gap” by withholding bugs</li>
      <li>search for full exploit until someone tries to claim a bounty</li>
      <li>solution: “submarine sends” see article on hackingdistributed.com</li>
    </ul>
  </li>
</ul>

<p>Bug witholding and commit-reveal:
Solution 1: to claim bounty at time T, must commit to bug at T-1 time
Problem: attacker commits in every round, and only reveals if someone else does</p>

<p>Solution 2: to commit, must pay $$ (in some verifiable way)
Problem: if committments are visible on chain, then attacker waits for someone else to commit and does so at the same time.</p>

<p>Solution 3: hide commitments (e.g. proof of burn to random address)
Problem: is wasteful</p>

<p>submarine sends (post-metropolis version)
goals:</p>
<ol>
  <li>only allow committed-users to send a transaction to C</li>
  <li>being eternally committed is expensive</li>
  <li>attacker can’t know if someone has committed</li>
  <li>money is not wasted</li>
</ol>

<p>submarine sends:
Phase 1: compute: addr = Hash(ContractAddr, nonce, code) and send $$ to addr
to an attacker, this looks like some random address on the network, a fresh address that hasn’t existed before. this kind of tx happens a lot in ehtereum so cannot ditinguish this send from other txs.</p>

<p>Phase 2: reveal addr to contract</p>
<ul>
  <li>C verifies that addr got $$ in phase 1</li>
  <li>C creates a contract with specified nonce, and code.</li>
  <li>C collects $$ and allows transaction</li>
</ul>

    </div>
  </body>
</html>
